# Дървовидна структура от полиморфни обекти

Искаме да реализираме клас за работа с **изрази от множества**.  

Искаме да имаме:
- Функция за парсване на израз от стринг;
- Функция, която приема елемент и връща дали елементът е част от полученото множество;
- Функция, която приема 2 израза и връща дали се получава едно и също множество.

---

## Представяне в паметта
Всеки израз от множества е:

 - Едно множество (синглетон);
 - Унарна операция, която има друг израз от множества;
 - Бинарна операция, която има ляв израз от множества и десен израз от множества.

![alt_text](https://i.ibb.co/VQj8Yj7/Set-Expression.png)

---

## Променливите, участващи в изразите от множества

При построяването на всеки израз ще пазим кои променливи участват. Отново това става по различен начин за трите вида изрази.

 - В множеството от един елемент участва само една променлива (самото множество);
 - В унарната операция участват точно тези променливи, които участват в подизраза;
 - В бинарната операция участват променливите от левия израз и променливите от десния израз (тяхното обединение).

![alt_text](https://i.ibb.co/B4hG7ht/Variables-In-The-Expr.png)

---

## Създаване на такъв израз по стринг

За да избегнем въвеждането на приоритет и прилагането на алгоритми като Shunting yard, ще въвеждаме изразите **със скоби около всяка операция**.  
Примерен такъв стринг: (((PvQ)^(TvR))v(!P)).

Как да разберем коя операция се прилага първа?
- Премахваме първата и последната скоба;
- Обхождаме стринга и използваме брояч. При срещането на отваряща скоба увеличаваме брояча с 1, а при срещането на затваряща - намаляваме брояча с 1;
- Символът за операция, който срещнем, когато броячът има стойност 0, е точно операцията, която трябва да се приложи първа. За аргументите на операцията извикваме същатата функция рекурсивно.

![alt_text](https://i.ibb.co/z4jhV88/Parsing.png)
