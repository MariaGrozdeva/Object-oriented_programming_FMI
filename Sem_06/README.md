# Капсулация (encapsulation) – първи принцип на Обектно-ориентираното програмиране

Искаме "външният свят" да **няма директен достъп до състоянието на даден обект**. То трябва да може да се променя единствено чрез създадените за целта член-функции.  

|Модификатор за достъп|Предназначение|  
|--|--|  
|private|Атрибутите, попадащи в обхвата на този модификатор, са вътрешни за съответния клас (не могат да се използват от "външния свят").|  
|protected|Като private + съответните атрибути могат да се използват и от наследниците на класа.|  
|public|Атрибутите, попадащи в обхвата на този модификатор, са видими и за "външния свят").|  

:bangbang: **Първа разлика между структура и клас**  
По подразбиране всички член данни и методи **на структурата са public-елементи**, а тези **на класа – private-елементи**.  

## Accessors and mutators (getters and setters)
**Get-ъри** – функции, които използваме за **достъп** до "скрити" данни (попадащи в обхвата на модификатора private (protected)).  
**Set-ъри** – функции, които използваме за **промяна** на "скрити" данни. В тях задължително правим валидация на подадените данни (ако такава е необходима)!  

*Пример:*  
```c++
class Student
{
private:
    unsigned int grade;
    unsigned int age;

public:
    unsigned int getGrade() const
    {
        return grade;
    }
    unsigned int getAge() const
    {
        return age;
    }

    void setGrade(unsigned int grade)
    {
        assert(grade <= 6);
        this->grade = grade;
    }
    void setAge(unsigned int age)
    {
        this->age = age;
    }
};
```

---

# Процес на компилация (oversimplified)

![alt_text](https://i.ibb.co/fD6XLJM/Compilation.png)

Нека нашият код се намира във файл с име Source.cpp. Как ще получим Source.exe?  
*Source.cpp* ->
1. **Препроцесор** – обработва препроцесорните директиви - #include, #define и други;
2. **Токенизация** – премахване на спейсове, табове, нови редове, коментари и т.н.;
3. **Синтактичен анализ** – проверка дали синтакисът на кода е валиден (чрез синтактични дървета);
4. **Семантичен анализ** – проверка дали семантиката на кода е валидна. Например, ако имате присвояване на някаква променлива на друга от несъвместим тип, в тази фаза ще се генерира грешка от вида "Assignment of incompatible type";
5. **Междинни генерализирани оптимизации** (cpu independent) – в тази фаза, ако имате проверки от вида на if (10 > 5) {...}, те ще се заменят директно с тялото на оператора (dead code elimination). Ще се случат и редица други оптимизации – loop optimization и т.н.;
6. **Генериране на assembly код**;
7. **Генериране на машинен код** за архитектурата от асемблер;
8. **Линкване** – събиране на всички .obj файлове и външни библиотеки;
9. **Още оптимизации** (cpu dependent)

-> *Source.exe*

---

# Разделна компилация

![alt_text](https://i.ibb.co/KsfDr85/h-cpp.png)

Какви грешки ще получим, изпълнявайки следните програмни фрагменти?  

1. 
```c++
int main()
{
	f();
	return 0;
}

int f()
{
	return 5;
}
```
**Компилаторът** дава грешка!  

2. 
```c++
int f();

int main()
{
	f();
	return 0;
}
```
**Линкерът** дава грешка!  

Всеки .cpp файл се обработва самостоятелно, без "да знае" за съществуването на останалите :bangbang:  

Ако имаме два .cpp файла, единият с код:
```c++
int f()
{
	return 5;
}
```
а другият:
```c++
int main()
{
	f();
	return 0;
}
```
отново ще получим **грешка на компилатора** по причината, спомената по- горе.  

Нека отново имаме два .cpp файла (first.cpp, second.cpp), единият с код:
```c++
int f()
{
	return 5;
}
```
а другият:
```c++
int f();

int main()
{
	f();
	return 0;
}
```
Какво ще се случи? Успешна компилация. :heavy_check_mark:

![alt_text](https://i.ibb.co/Gcywtts/Linking.png)

---

![alt_text](https://i.ibb.co/7kxRV1K/Compilation-2.png)

Една програма на С++ може да бъде разбита в множество файлове, които **се компилират независимо един от друг**, т.е. се осъществява **разделна компилация**. В резултат на компилацията се получават няколко **обектни файла** (файлове с разширение **.obj**). Изпълнимият код на програмата (файл с разширение **.ехе**) се получава след свързване (**linking**) на обектните файлове (и външните библиотеки).  

За да се възполваме максимално от разделната компилация, разделяме класовете на **.h** и **.cpp** файлове. Навсякъде, където работим с класа, ще включваме **само .h файла**. По този начин, ако променим реализацията на някоя от функциите на класа, ще се  **прекомпилира само този файл**.  

---

## Задача 1:
Да се реализира **class Time** за работа с часове.  
Класът трябва да съдържа поне следните методи:
- Подразбиращ се контруктор, който създава часа на 00:00:00.
- Конструктор, който приема три параметъра – час, минути и секунди.
- Член-функция, която връща оставащото време до полунощ.
- Член-функция, която увеличава часа с 1 секунда.
- Член-функция, която връща дали е време за вечеря. В рамките на задачата време за вечеря е между 20:30 и 22:00.
- Член-функция, която връща дали е време за купон. В рамките на задачата време за купон е между 23:00 и 06:00.
- Член-функция, която приема друг обект от тип Time и връща обект от тип Time, съответстващ на разликата между двете времена.
- Член-функция, която приема друг обект от тип Time и сравнява двата обекта.
- Член-функция за принтиране на часа.

## Задача 2:
Да се реализира **class Date** за работа с дати.  
Класът трябва да съдържа поне следните методи:

- Конструктор, който приема три параметъра – година, месец и ден.
- Гетъри и сетъри за всички член-данни.
- Член-функция, която приема друг обект от тип Date и връща дали двата обекта са равни.
- Член-функция, която връща кой ден от седмицата е (понеделник-неделя).
- Член-функция, която връща следващата дата.
- Член-функция за принтиране на датата.

## Задача 3:
Да се реализира **class Event** за работа със събития.  
Класът трябва да съдържа поне следните методи:

- Конструктор, който приема три параметъра – име на събитието, дата на провеждане и начален час.
- Гетъри за всички член-данни.
- Член-функция, която връща през кой ден от седмицата се провежда събитието (понеделник-неделя).
- Член-функция за принтиране на събитието.

## Задача 4:
Да се реализира **class EventCollection** за работа с колекция от събития.  
Класът трябва да съдържа поне следните методи:

- Член-функция за добавяне на събитие.
- Член-функция за премахване на събитие по име.
- Член-функция за намиране на най-дългото събитие.
- Член-функция, която приема дата и връща максималния брой събития, които може да се посетят в този ден (за да се посетят 2 събития, те не трябва да се пресичат).

:bangbang: В задачите да се спазва принципа за **разделна компилация**.  
