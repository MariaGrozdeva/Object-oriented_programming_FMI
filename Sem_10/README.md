# Изключения (Exceptions)

В една програма могат да възникнат различни типове грешки: 
- **синтактични грешки**, които се откриват по време на компилация;
- **семантични грешки**, които се откриват по време на изпълнение на програмата.

Често срещани проблеми, които трябва да могат да бъдат предвидени и да може да се реагира на тях, са например:
- параметри с невалидни стойности, подадени на дадена функция;
- възникване на грешка по време на изпълнение на функция, в следствие на която функцията връща определен резултат;
- грешен формат на потребителски вход на дадена програма.

#### Възникване на грешка в конструктор

Задачата на всеки конструктор е да създаде валиден обект. В допълнение, всяка публична член-функция, която се изпълнява върху обект, предполага начално валидно състояние и трябва да остави обекта отново във валидно състояние.  

Конструкторът не връща стойност, той не може да върне код за грешка. Как да се реагира в случай на проблем или на невалидни входни данни? Дори да се добави аргумент, който да указва дали всичко е преминало успешно, в крайна сметка обект ще бъде конструиран, дори той да не е валиден.  

До сега в конструкторите на класовете с подобни проблеми се справяхме по няколко начина:
1. **Обектът се маркира като невалиден.** Това означава, че при всяка операция (член-функция на класа), която се прилага над обект от този клас, трябва да се проверява дали се работи с валиден обект.  
**Пример:**
```c++
Rational::Rational(int numerator, int denominator) : numerator(numerator), denominator(denominator)
{}
bool Rational::isValid() const
{
	return denominator != 0;
}

int main()
{
	Rational r(1, 0);
	if (r.isValid())
		// code
}
```

2. **Обектът се поправя локално**, подменя се с валиден.  
**Пример:**
```c++
Rational::Rational(int numerator, int denominator) : numerator(numerator)
{
	if (denominator == 0)
		denominator = 1;
	this->denominator = denominator;
}
```

Дали тези подходи са добри? **Не** :bangbang:  
**Проблемът се „смита под килима“**. Не се сигнализира за него.  
Дали има друг механизъм за справяне в такива ситуации? **Да**.  

**Изключенията** са механизъм за сигнализация за неочаквана (изключителна) ситуация, различна от очаквания, основен ход на събитията. Идеята е да се подаде съобщение за проблем, възникнал по време на изпълнение на програмата, и някой, който може да реши проблема, да поеме отговорност и да възстанови нормалния ход на нещата. С изключенията в езика са свързани три ключови думи: **throw**, **try** и **catch**.

## Хвърляне на изключение

За да бъде сигнализирано за възникването на определена неочаквана ситуация, различна от това, което програмата може да обработи, се използва следната конструкция:  
**throw <израз>;**  
<израз> е съобщението към външния свят и може да бъде от произволен тип. Обикновено това е код на грешка (константа от изброен тип), символен низ с описание на грешката, може да бъде дори обект от потребителски дефиниран тип.  

**Примери:**  
throw INVALID_INDEX;  
throw “Index out of range!”;  
throw InvalidStudentsIDException();

## Прихващане на изключения

Ключовата дума **try** се използва, за да дефинира блок от операции, който ще бъде наблюдаван за възникване на изключения. Всяка операция в рамките на блока се проверява. Ако възникне изключение, то се прихваща само ако **try блокът** е последван от **catch блок** с тип, съответстващ на възникналото изключение. Всеки try блок трябва да има поне един catch блок, а може и да е последвано от няколко такива.  

**Пример:**  
```c++
std::cout << "Before the try block..." << std::endl;
try
{
	std::cout << "Inside the try block, before the throw..." << std::endl;
	throw "Error"; // изключението е от тип символен низ
	std::cout << "Inside the try block, after the throw..." << std::endl;
}
catch (const char* expr) // това, което е обявено като тип в catch блока трябва да съвпада с типа на изключението
{
	std::cerr << "Exception caught: " << expr << std::endl;
}
std::cout << "After the try block, after the throw..." << std::endl;
```

- Ако в тялото на try блока **не възникне изключение**, всички catch блокове се игнорират и изпълнението продължава от първата операция след последния catch блок.
- Ако в тялото на try блока **възникне изключение**, което няма съответстващ catch блок или възникне изключение извън try блок, съдържащата го функция (т.е. функцията, в която е възникнало изключението) прекъсва, при което всички локални променливи се освобождават и програмата се опитва да намери try блок в извикващата функция. Извършва се **изкачване по стека (stack unwinding)**.

### Изключения в конструкторите

Ако конструктор не успее по някаква причина да създаде валиден обект, например при подадени некоректни стойности за член-данните, може да се хвърли изключение, с което да се сигнализира, че обектът не е създаден успешно.  

При възникване на грешка в конструктор, **деструкторът на класа не се извиква** :bangbang:  
Следователно не може да се разчита на него да освободи външни ресурси, ангажирани преди възникването на грешката. 
**Освобождаването на тези ресурси трябва да се осъществи преди хвърлянето на изключението**. Ако в класа има вградени обекти от други класове, за тях ще бъдат извикани деструктори.
```c++
class Item
{
private:
	char* name;
	char id[6];
	double price;
	
public:
	Item(const char* id, const char* name, double price);
	Item(const Item& other);
	Item& operator=(const Item& other);
	~Item();
	// ...
};

Item::Item(const char* name, const char* id, double price)
{
	if (name == nullptr)
		throw "Invalid name!";
	// ако паметта за името е заделена първо
	this->name = new char[strlen(name) + 1];
	strcpy(this->name, name);

	if (!isValid(id)) 
	{
		// трябва да се освободи паметта за името преди да се хвърли изключение
		delete[] this->name;
		throw "Invalid id!";
	}
	strcpy(this->id, id);

	if (price < 0)
	{
		delete[] this->name;
		throw "Invalid price!";
	}
	this->price = price;
}
```

По- изчистена реализация на същата функция:
```c++
Item::Item(const char* name, const char* id, double newPrice){
	if (!isValid(id))
		throw "Invalid id!";
	strcpy(this->id, id);

	if (price < 0)
		throw "Invalid price!";
	this->price = price;

	// може името да се обработи последно 
	if (name == nullptr)
		throw "Invalid name!";
	this->name = new char[strlen(name) + 1];
	strcpy(this->name, name);
}
```

### Изключения в деструкторите

Изключенията не трябва да напускат деструкторите. Ако възникне изключение в деструктора, то трябва да се прихване и да се обработи, ако е възможно да бъдат освободени всички заделени външни ресурси. Проблемът при възникване на изключение в деструктор е, че при превъртането на стека при обработка на изключение се извикват деструкторите на всички локални обекти. Ако от такъв деструктор възникне изключение, то компилаторът не е в състояние да обработи новото изключение успоредно с текущото и възниква конфликт. В крайна сметка, програмата ще бъде прекъсната веднага без възможност за обработка.

## Нива на сигурност при изключенията

Съществуват няколко различни нива на сигурност при възникване на изключение. 

### No-throw guarantee
Операциите винаги са успешни. Дори и да възникне някакво изключение, то се обработва вътрешно и външният свят не разбира за него. Пример за такава функция е преместващият конструктор.

### Силна сигурност (strong exception safety guarantee)
Операциите могат да пропаднат, но ако дадена операция пропадне, то няма да има странични ефекти от нея и обектът остава в оригиналното си състояние. Понякога се постига по-трудно.

### Слаба сигурност (weak/basic exception safety guarantee)
Частично изпълнение на операциите, което може да доведе до странични ефекти. Обектът е във валидно състояние, което може да е различно от първоначалното. Няма изтичане на ресурси.

### No exception safety
Няма никаква гаранция за състоянието на обектите и операциите.

---

Да допуснем, че възниква изключение при заделянето на памет за name:  

**Пример за basic exception safety guarantee:**
```c++
Item& Item::operator=(const Item& other)
{
	if (this != &other) 
	{
		this->setID(other.id);
		this->setPrice(other.price);
		this->setName(other.name);
	}
	return *this;
}
```

**Пример за strong exception safety guarantee:**
```c++
Item& Item::operator=(const Item& other)
{
	if (this != &other) 
	{
		this->setName(other.name);
		this->setID(other.id);
		this->setPrice(other.price);
	}
	return *this;
}
```

# Статични член-данни и член-функции

Когато се създава обект от даден клас, този обект разполага със **свое собствено копие** на член-данните. Когато обаче член-данните са декларирани като **статични (с ключовата дума static)**, те се **споделят от всички обекти на класа**.  

Характеристики на **статичните член-данни**:
1. Статичните член-данни се **декларират в класа**. Преди да бъдат използвани, те трябва да бъдат дефинирани и инициализирани. Освен в някои случаи, това се случва извън декларацията на класа.
2. Памет за статичните член-данни се заделя не върху стека, а в **областта за статични данни**.
3. **Памет за статичните член-данни се заделя еднократно**. Всички обекти от класа имат достъп до нея.
4. Статичните член-данни се създават, когато се стартира програмата и се унищожават, когато програмата приключи. Тъй като те съществуват преди изобщо да има създадени обекти от класа, **те се свързват със самия клас, а не с някой конкретен обект**. Най-добре е достъпът до тях да се осъществява през класа (с оператор за принадлежност ::), а не през обект.  

Характеристики на **статичните член-функции**:
1. Тъй като статичните член-функции могат да бъдат извикани през самия клас, дори без да
съществуват обекти от този клас, то **в тях няма дефиниран указател this**.
2. След като не се изпълняват върху конкретен текущ обект, то в тях не могат да се използват
други член-данни на класа, които не са статични. **В статичните член-функции могат да се
използват само статични член-данни**.
3. Статичните член-функции **не могат да бъдат константни**. Причината отново е, че не се
изпълняват върху конкретен текущ обект.
4. Препоръчително е статичните член-функции (както и статичните член-данни) да бъдат
използвани **само с пълното име на класа, а не през обект**.

### Задача
Да се реализира клас ObjectCounter, който **следи броя на живите си обекти**.  Всеки обект има свой уникален идентификатор - цяло неотрицателно число. Броят на живите обекти НЕ може да бъде деклариран като обикновена член-данна. Той трябва да се променя (достъпва) при създаването на обект от съответния конструктор, както и при унищожаването на обект от деструктора на класа.

# Move семантики

### lvalue и rvalue

**lvalue** - обект, който заема някакво конкретно място в паметта.  
**rvalue** - временен обект (някакъв израз) с временен адрес (регистър). Унищожава се "почти веднага" след като е създаден (в края на израза, в който е бил създаден).  

**&** - за **lvalue**  
**Пример:**  
```c++
#include <iostream>

bool f(int& n)
{
	return n % 2 == 0;
}
int main()
{
	int n = 10;
	f(n); // OK! n is lvalue
	f(5); // Error! 5 is not an lvalue
}
```

**&&** - за **rvalue**  
**Пример:**  
```c++
bool f(int&& n)
{
	return n % 2 == 0;
}
int main()
{
	int n = 10;
	f(n); // Error! n is not an rvalue
	f(5); // OK! 5 is rvalue
}
```

Да разгледаме следния програмен фрагмент:
```c++
MyString createString(const char* str)
{
	MyString createdString(str);
	return createdString;
}

int main()
{
	MyString str("Algebra");
	str = createString("OOP");
}
```
Резултат от изпълнението:

![alt_text](https://i.ibb.co/3SV5J2c/Copy-Constr.png)

**Проблем:** Правим излишни копия :bangbang: Обектът, създаден в createString **се копира два пъти преди да се присвои** на str.

## Move конструктор и move оператор=
```c++
MyString::MyString(MyString&& other)
{
	str = other.str;
	size = other.size;
	other.str = nullptr;
	other.size = 0;
}

MyString& MyString::operator=(MyString&& other)
{
	if (this != &other)
	{
		free();
		
		str = other.str;
		size = other.size;
		other.str = nullptr;
		other.size = 0;
	}
	return *this;
}
```
Резултат от изпълнението на по- горния програмен фрагмент:

![alt_text](https://i.ibb.co/MPYRScW/Move.png)

Допълнителни материали:  
https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c  
https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners
